{
    "problem_id": "32",
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position due to the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. The dynamics of phonon occupation are simulated for small oscillations along the $x$-axis near the equilibrium positions of each sphere, with the central difference method used for computing the derivatives in the simulation.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "required_dependencies": "import numpy as np\nfrom scipy.constants import epsilon_0, c\nfrom typing import List",
    "problem_io": "def solve_multiparticle_dynamics(N: int, t0: float, R: float, l: float, phi: float, P: list[float], n0: list[float], w: float, a: float, n: float, h: float, rho: float, steps: int, L: np.ndarray = None, M: np.ndarray = None, gamma: np.ndarray = None) -> list[float]:\n    \"\"\"\n    Simulates phonon occupation dynamics in an optical tweezer array.\n\n    Args:\n        N (int): Number of nanospheres.\n        t0 (float): Time for simulation (seconds).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of optical tweezers (meters).\n        phi (float): Polarization angle (radians).\n        P (list): Powers of optical tweezers (Watts).\n        n0 (list): Initial phonon occupation numbers.\n        w (float): Beam waist of optical tweezers (meters).\n        a (float): Radius of nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n        h (float): Step size for numerical derivative (meters).\n        rho (float): Density of nanospheres (kg/m\u00b3).\n        steps (int): Number of RK4 time steps.\n        L (np.ndarray, optional): Coupling matrix for the nanospheres.\n        M (np.ndarray, optional): Mass matrix for the nanospheres.\n        gamma (np.ndarray, optional): Damping coefficient for nanospheres.\n\n    Returns:\n        list: Phonon occupation numbers at time t0.\n    \"\"\"",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "If we suppose the nanospheres are placed on the $x$-axis while each nanosphere is trapped by a linearly polarized laser beam propagating along the $z$-axis, we have the induced dipole moments as $\\mathbf{p}_1 = \\alpha \\mathbf{E}_1$ and $\\mathbf{p}_2 = \\alpha \\mathbf{E}_2$, where $\\alpha = 4\\pi \\varepsilon_0 a^3 \\frac{n^2 - 1}{n^2 + 2}$ is the scalar polarizability of the nanospheres. The trapping electric field $E_i$ is related to the laser power $P_i$ by:",
            "ground_truth_code": "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Pico-Newtons).\n    \"\"\"\n    k = 2 * np.pi / l  # Wave number\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)  # Polarizability\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))  # Electric field for sphere 1\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))  # Electric field for sphere 2\n\n    Fxx = (\n        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    )\n    Fxy = (\n        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n    )\n    return (Fxx + Fxy) * 1e12  # Convert to pico-Newtons",
            "function_header": "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Pico-Newtons).\n    \"\"\"",
            "test_cases": [
                "# 32.1 # Test case 1\nP = [50, 50]\nphi = 0\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = 3.305455280955525\nresult = calculate_binding_force(P, phi, R, l, w, a, n)\nassert np.allclose(result, target, rtol=1e-4, atol=1e-8), f\"Result {result} does not match target {target}\"\n\n# Test case 2\nP = [50, 50]\nphi = np.pi/2\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = -3.441376278823615\nresult = calculate_binding_force(P, phi, R, l, w, a, n)\nassert np.allclose(result, target, rtol=1e-4, atol=1e-8), f\"Result {result} does not match target {target}\"\n\n# Test case 3\nP = [50, 50]\nphi = np.pi/4\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = -0.06796049893404463\nresult = calculate_binding_force(P, phi, R, l, w, a, n)\nassert np.allclose(result, target, rtol=1e-4, atol=1e-8), f\"Result {result} does not match target {target}\""
            ]
        },
        {
            "step_number": "32.2",
            "step_name": "Generate Hamiltonian",
            "step_description_prompt": "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, considering the damping coefficient array and the linearized optical binding force acting upon the trapped nanospheres.",
            "step_background": "Around the equilibrium position, the optical binding force between nanospheres is linearized as:",
            "ground_truth_code": "def generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list[float]): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n        k_ij (np.ndarray): Pairwise binding forces (pN/m)\n        gamma (np.ndarray): Damping coefficients for each nanosphere\n\n    Returns:\n        np.ndarray: NxN Hamiltonian matrix\n    \"\"\"\n    m = (4 / 3) * np.pi * (a**3) * rho\n    alpha = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1) / (n**2 + 2))\n    k_i = np.array([(8 * alpha * p) / (np.pi * w * epsilon_0 * c) for p in P]) * 1e12  # Convert to pN/m\n\n    # Compute effective spring constants\n    k_eff = k_i + np.sum(k_ij, axis=1)\n    # Avoid negatives\n    k_eff = np.clip(k_eff, 1e-6, None)  # Ensure k_eff > 0\n\n    # Compute resonant frequencies squared\n    Omega_squared = np.clip(k_eff / m - gamma**2, 0, None)\n    # Compute resonant frequencies\n    Omega = np.sqrt(Omega_squared)\n\n    # Construct Hamiltonian matrix\n    H = np.zeros((N, N))\n    np.fill_diagonal(H, Omega)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if Omega[i] > 0 and Omega[j] > 0:\n                g_ij = -k_ij[i, j] / (2 * m * np.sqrt(Omega[i] * Omega[j]))\n                H[i, j] = g_ij\n    H += H.T  # Ensure symmetry\n    return H",
            "function_header": "def generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list[float]): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n        k_ij (np.ndarray): Pairwise binding forces (pN/m)\n        gamma (np.ndarray): Damping coefficients for each nanosphere\n\n    Returns:\n        np.ndarray: NxN Hamiltonian matrix\n    \"\"\"",
            "test_cases": [
                "# Test Case 1: Uniform Damping\nP = [50, 50, 50, 50, 50]\ngamma = np.array([1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9])\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nN = np.size(P)\nrho = 2.648e3\n\n# Pairwise binding forces (pN)\nk_ij = np.array([\n    [0.0, -4.19639445e-11, -1.04909861e-11, -4.66266050e-12, -2.62274653e-12],\n    [-4.19639445e-11, 0.0, -4.19639445e-11, -1.04909861e-11, -4.66266050e-12],\n    [-1.04909861e-11, -4.19639445e-11, 0.0, -4.19639445e-11, -1.04909861e-11],\n    [-4.66266050e-12, -1.04909861e-11, -4.19639445e-11, 0.0, -4.19639445e-11],\n    [-2.62274653e-12, -4.66266050e-12, -1.04909861e-11, -4.19639445e-11, 0.0],\n])\n\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\ntarget = [\n    [6.00518928e+05, 6.30003574e+00, 1.57500893e+00, 7.00003971e-01, 3.93752234e-01],\n    [6.30003574e+00, 6.00518928e+05, 6.30003574e+00, 1.57500893e+00, 7.00003971e-01],\n    [1.57500893e+00, 6.30003574e+00, 6.00518928e+05, 6.30003574e+00, 1.57500893e+00],\n    [7.00003971e-01, 1.57500893e+00, 6.30003574e+00, 6.00518928e+05, 6.30003574e+00],\n    [3.93752234e-01, 7.00003971e-01, 1.57500893e+00, 6.30003574e+00, 6.00518928e+05]\n]\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Result {output} does not match target {target}\"\n\n# Test Case 2: Increased Distance\nR = 2 * 1550e-9  # Increased distance\nk_ij = np.array([\n    [0.0, -1.04058273e-11, -2.60145682e-12, -1.15620303e-12, -6.50364204e-13],\n    [-1.04058273e-11, 0.0, -1.04058273e-11, -2.60145682e-12, -1.15620303e-12],\n    [-2.60145682e-12, -1.04058273e-11, 0.0, -1.04058273e-11, -2.60145682e-12],\n    [-1.15620303e-12, -2.60145682e-12, -1.04058273e-11, 0.0, -1.04058273e-11],\n    [-6.50364204e-13, -1.15620303e-12, -2.60145682e-12, -1.04058273e-11, 0.0],\n])\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\ntarget = [\n    [6.00518928e+05, 1.56222406e+00, 3.90556015e-01, 1.73580451e-01, 9.76390036e-02],\n    [1.56222406e+00, 6.00518928e+05, 1.56222406e+00, 3.90556015e-01, 1.73580451e-01],\n    [3.90556015e-01, 1.56222406e+00, 6.00518928e+05, 1.56222406e+00, 3.90556015e-01],\n    [1.73580451e-01, 3.90556015e-01, 1.56222406e+00, 6.00518928e+05, 1.56222406e+00],\n    [9.76390036e-02, 1.73580451e-01, 3.90556015e-01, 1.56222406e+00, 6.00518928e+05]\n]\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Result {output} does not match target {target}\"\n\n# Test Case 3: High Damping\nk_ij = np.array([\n    [0.0, -1.5e-9, -5.0e-10, -2.0e-10, -1.0e-10],\n    [-1.5e-9, 0.0, -1.5e-9, -5.0e-10, -2.0e-10],\n    [-5.0e-10, -1.5e-9, 0.0, -1.5e-9, -5.0e-10],\n    [-2.0e-10, -5.0e-10, -1.5e-9, 0.0, -1.5e-9],\n    [-1.0e-10, -2.0e-10, -5.0e-10, -1.5e-9, 0.0],\n])\n\ngamma = np.array([1e-8, 1e-8, 1e-8, 1e-8, 1e-8])\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\ntarget = [\n    [6.00518928e+05, 2.25194598e+02, 7.50648660e+01, 3.00259464e+01, 1.50129732e+01],\n    [2.25194598e+02, 6.00518928e+05, 2.25194598e+02, 7.50648660e+01, 3.00259464e+01],\n    [7.50648660e+01, 2.25194598e+02, 6.00518928e+05, 2.25194598e+02, 7.50648660e+01],\n    [3.00259464e+01, 7.50648660e+01, 2.25194598e+02, 6.00518928e+05, 2.25194598e+02],\n    [1.50129732e+01, 3.00259464e+01, 7.50648660e+01, 2.25194598e+02, 6.00518928e+05]\n]\n\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Result {output} does not match target {target}\"\n\n# Test Case 4: Zero Damping\nk_ij = np.array([\n    [0.0, -1.5e-10, -5.0e-11, -2.0e-11, -1.0e-11],\n    [-1.5e-10, 0.0, -1.5e-10, -5.0e-11, -2.0e-11],\n    [-5.0e-11, -1.5e-10, 0.0, -1.5e-10, -5.0e-11],\n    [-2.0e-11, -5.0e-11, -1.5e-10, 0.0, -1.5e-10],\n    [-1.0e-11, -2.0e-11, -5.0e-11, -1.5e-10, 0.0],\n])\n\ngamma = np.zeros(N)\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\ntarget = [\n    [6.00518928e+05, 2.25194598e+01, 7.50648660e+00, 3.00259464e+00, 1.50129732e+00],\n    [2.25194598e+01, 6.00518928e+05, 2.25194598e+01, 7.50648660e+00, 3.00259464e+00],\n    [7.50648660e+00, 2.25194598e+01, 6.00518928e+05, 2.25194598e+01, 7.50648660e+00],\n    [3.00259464e+00, 7.50648660e+00, 2.25194598e+01, 6.00518928e+05, 2.25194598e+01],\n    [1.50129732e+00, 3.00259464e+00, 7.50648660e+00, 2.25194598e+01, 6.00518928e+05]\n]\n\n\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Result {output} does not match target {target}\"\n\n# Test Case 5: Non-Uniform Damping\ngamma = np.array([1.88e-9, 2.5e-9, 1.5e-9, 3.0e-9, 2.0e-9])\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\ntarget = [\n    [6.00518928e+05, 2.25194598e+01, 7.50648660e+00, 3.00259464e+00, 1.50129732e+00],\n    [2.25194598e+01, 6.00518928e+05, 2.25194598e+01, 7.50648660e+00, 3.00259464e+00],\n    [7.50648660e+00, 2.25194598e+01, 6.00518928e+05, 2.25194598e+01, 7.50648660e+00],\n    [3.00259464e+00, 7.50648660e+00, 2.25194598e+01, 6.00518928e+05, 2.25194598e+01],\n    [1.50129732e+00, 3.00259464e+00, 7.50648660e+00, 2.25194598e+01, 6.00518928e+05]\n]\n\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Result {output} does not match target {target}\""
            ]
        },
        {
            "step_number": "32.3",
            "step_name": "Runge-Kutta for Phonon Dynamics",
            "step_description_prompt": "Write a Python function to implement the fourth-order Runge-Kutta (RK4) method to simulate phonon occupation dynamics of the trapped nanosphere system. The dynamics are governed by the Lindblad master equation for the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, where the Hamiltonian $H$ is represented in the basis of the outer products of the ladder operators $b_i^\\dagger b_j$, and includes a factor of $\\hbar$ (i.e., $H = \\hbar \\tilde{H}$). The Lindblad master equation is expressed as:",
            "step_background": "The Lindblad master equation governs the evolution of the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, which describes the dynamics of an open quantum system. The correlation matrix $C$ is derived from the density matrix $\\rho$ by relating the expectation of the operators $b_i^\\dagger b_j$ as $\\langle b_i^\\dagger b_j \\rangle = \\operatorname{tr}(\\rho b_i^\\dagger b_j)$. For the Lindblad equation, the Hamiltonian $H$ is expressed in the basis of the outer products of the ladder operators $b_i^\\dagger b_j$, and it is scaled by $\\hbar$ (i.e., $H = \\hbar \\tilde{H}$). The Lindblad master equation is given by:",
            "ground_truth_code": "def runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n    \"\"\"\n    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"\n    H_max = np.max(np.abs(H))\n    if H_max <= 0 or np.isnan(H_max):\n        raise ValueError(\"Hamiltonian max value is zero or invalid, cannot normalize.\")\n    H_normalized = H / H_max\n    L_normalized = L / H_max\n    M_normalized = M / H_max\n    delta_t = t0 / steps\n    C = np.array(C0, dtype=np.complex128)\n\n    def commutator(A, B):\n        return np.dot(A, B) - np.dot(B, A)\n\n    def anticommutator(A, B):\n        return np.dot(A, B) + np.dot(B, A)\n\n    for _ in range(steps):\n        k1 = 1j * commutator(H_normalized, C) + anticommutator(L_normalized, C) + M_normalized\n        k2 = 1j * commutator(H_normalized, C + 0.5 * k1 * delta_t) + anticommutator(L_normalized, C + 0.5 * k1 * delta_t) + M_normalized\n        k3 = 1j * commutator(H_normalized, C + 0.5 * k2 * delta_t) + anticommutator(L_normalized, C + 0.5 * k2 * delta_t) + M_normalized\n        k4 = 1j * commutator(H_normalized, C + k3 * delta_t) + anticommutator(L_normalized, C + k3 * delta_t) + M_normalized\n        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return np.diag(C).real",
            "function_header": "def runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n    \"\"\"\n    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"",
            "test_cases": [
                "# 32.3 - Test case 1\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [1.89901202e+07, 1.99224160e-01, 4.98060400e-02, 2.21360178e-02, 1.24515099e-02],\n    [1.99224160e-01, 1.89901198e+07, 1.99224162e-01, 4.98060404e-02, 2.21360178e-02],\n    [4.98060400e-02, 1.99224162e-01, 1.89901198e+07, 1.99224162e-01, 4.98060400e-02],\n    [2.21360178e-02, 4.98060404e-02, 1.99224162e-01, 1.89901198e+07, 1.99224160e-01],\n    [1.24515099e-02, 2.21360178e-02, 4.98060400e-02, 1.99224160e-01, 1.89901202e+07],\n]\n\nL = - Gamma * np.identity(N) / 2\nM = 2372 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\ntarget = [3.95499532e+07, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02]\noutput = runge_kutta_dynamics(C0, H, L, M, t0, steps)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n# 32.3 - Test case 2\nn0 = [197.25, 39549953.17, 39549953.17, 39549953.17, 39549953.17]\nGamma = 0.001\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [1.89901206e+07, 4.94017463e-02, 1.23504366e-02, 5.48908291e-03, 3.08760913e-03],\n    [4.94017463e-02, 1.89901205e+07, 4.94017465e-02, 1.23504366e-02, 5.48908291e-03],\n    [1.23504366e-02, 4.94017465e-02, 1.89901205e+07, 4.94017465e-02, 1.23504366e-02],\n    [5.48908291e-03, 1.23504366e-02, 4.94017465e-02, 1.89901205e+07, 4.94017463e-02],\n    [3.08760913e-03, 5.48908291e-03, 1.23504366e-02, 4.94017463e-02, 1.89901206e+07],\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 10000\ntarget = [1.97250000e+02, 3.95499532e+07, 3.95499532e+07, 3.95499532e+07, 3.95499532e+07]\noutput = runge_kutta_dynamics(C0, H, L, M, t0, steps)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n\n# 32.3 - Test case 3\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [1.89901202e+07, 1.97606991e-01, 4.94017479e-02, 2.19563323e-02, 1.23504368e-02],\n    [1.97606991e-01, 1.89901198e+07, 1.97606993e-01, 4.94017483e-02, 2.19563323e-02],\n    [4.94017479e-02, 1.97606993e-01, 1.89901198e+07, 1.97606993e-01, 4.94017479e-02],\n    [2.19563323e-02, 4.94017483e-02, 1.97606993e-01, 1.89901198e+07, 1.97606991e-01],\n    [1.23504368e-02, 2.19563323e-02, 4.94017479e-02, 1.97606991e-01, 1.89901202e+07],\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 50000\ntarget = [3.95499532e+07, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02]\noutput = runge_kutta_dynamics(C0, H, L, M, t0, steps)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n\n# 32.3 - Test case 4\nn0 = [197.25, 197.25, 39549953.17, 197.25, 197.25]\nGamma = 0\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [1.89901202e+07, 1.99224160e-01, 4.98060400e-02, 2.21360178e-02, 1.24515099e-02],\n    [1.99224160e-01, 1.89901198e+07, 1.99224162e-01, 4.98060404e-02, 2.21360178e-02],\n    [4.98060400e-02, 1.99224162e-01, 1.89901198e+07, 1.99224162e-01, 4.98060400e-02],\n    [2.21360178e-02, 4.98060404e-02, 1.99224162e-01, 1.89901198e+07, 1.99224160e-01],\n    [1.24515099e-02, 2.21360178e-02, 4.98060400e-02, 1.99224160e-01, 1.89901202e+07],\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\nnf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\ndiff = sum(nf) - sum(n0)\ntarget = (np.True_, np.True_)\ndef is_symmetric(array, rtol=1e-05, atol=1e-08):\n    return np.all(np.isclose(array, array[::-1], rtol=rtol, atol=atol))\nassert (abs(diff)<1e-6, is_symmetric(nf)) == target\n\n# 32.3 - Test case 5 - Different M coefficient, same step count range\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [1.89901151e+07, 1.99224231e+00, 4.98060584e-01, 2.21360257e-01, 1.24515132e-01],\n    [1.99224231e+00, 1.89901114e+07, 1.99224254e+00, 4.98060626e-01, 2.21360257e-01],\n    [4.98060584e-01, 1.99224254e+00, 1.89901108e+07, 1.99224254e+00, 4.98060584e-01],\n    [2.21360257e-01, 4.98060626e-01, 1.99224254e+00, 1.89901114e+07, 1.99224231e+00],\n    [1.24515132e-01, 2.21360257e-01, 4.98060584e-01, 1.99224231e+00, 1.89901151e+07],\n]\nL = - Gamma * np.identity(N) / 2\nM = 500 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\ntarget = [3.95499532e+07, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02, 1.97250000e+02]\noutput = runge_kutta_dynamics(C0, H, L, M, t0, steps)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\""
            ]
        }
    ],
    "general_solution": "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Pico-Newtons).\n    \"\"\"\n    k = 2 * np.pi / l  # Wave number\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)  # Polarizability\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))  # Electric field for sphere 1\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))  # Electric field for sphere 2\n\n    Fxx = (\n        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    )\n    Fxy = (\n        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n    )\n    return (Fxx + Fxy) * 1e12  # Convert to pico-Newtons\n\ndef generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list[float]): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n        k_ij (np.ndarray): Pairwise binding forces (pN/m)\n        gamma (np.ndarray): Damping coefficients for each nanosphere\n\n    Returns:\n        np.ndarray: NxN Hamiltonian matrix\n    \"\"\"\n    m = (4 / 3) * np.pi * (a**3) * rho\n    alpha = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1) / (n**2 + 2))\n    k_i = np.array([(8 * alpha * p) / (np.pi * w * epsilon_0 * c) for p in P]) * 1e12  # Convert to pN/m\n\n    # Compute effective spring constants\n    k_eff = k_i + np.sum(k_ij, axis=1)\n    # Avoid negatives\n    k_eff = np.clip(k_eff, 1e-6, None)  # Ensure k_eff > 0\n\n    # Compute resonant frequencies squared\n    Omega_squared = np.clip(k_eff / m - gamma**2, 0, None)\n    # Compute resonant frequencies\n    Omega = np.sqrt(Omega_squared)\n\n    # Construct Hamiltonian matrix\n    H = np.zeros((N, N))\n    np.fill_diagonal(H, Omega)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if Omega[i] > 0 and Omega[j] > 0:\n                g_ij = -k_ij[i, j] / (2 * m * np.sqrt(Omega[i] * Omega[j]))\n                H[i, j] = g_ij\n    H += H.T  # Ensure symmetry\n    return H\n\ndef runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n    \"\"\"\n    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"\n    H_max = np.max(np.abs(H))\n    if H_max <= 0 or np.isnan(H_max):\n        raise ValueError(\"Hamiltonian max value is zero or invalid, cannot normalize.\")\n    H_normalized = H / H_max\n    L_normalized = L / H_max\n    M_normalized = M / H_max\n    delta_t = t0 / steps\n    C = np.array(C0, dtype=np.complex128)\n\n    def commutator(A, B):\n        return np.dot(A, B) - np.dot(B, A)\n\n    def anticommutator(A, B):\n        return np.dot(A, B) + np.dot(B, A)\n\n    for _ in range(steps):\n        k1 = 1j * commutator(H_normalized, C) + anticommutator(L_normalized, C) + M_normalized\n        k2 = 1j * commutator(H_normalized, C + 0.5 * k1 * delta_t) + anticommutator(L_normalized, C + 0.5 * k1 * delta_t) + M_normalized\n        k3 = 1j * commutator(H_normalized, C + 0.5 * k2 * delta_t) + anticommutator(L_normalized, C + 0.5 * k2 * delta_t) + M_normalized\n        k4 = 1j * commutator(H_normalized, C + k3 * delta_t) + anticommutator(L_normalized, C + k3 * delta_t) + M_normalized\n        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return np.diag(C).real\n\ndef solve_multiparticle_dynamics(N: int, t0: float, R: float, l: float, phi: float, P: list[float], n0: list[float], w: float, a: float, n: float, h: float, rho: float, steps: int, L: np.ndarray = None, M: np.ndarray = None, gamma: np.ndarray = None) -> list[float]:\n\n    \"\"\"\n    Simulates phonon occupation dynamics in an optical tweezer array.\n\n        Args:\n            N (int): Number of nanospheres.\n            t0 (float): Time for simulation (seconds).\n            R (float): Distance between adjacent nanospheres (meters).\n            l (float): Wavelength of optical tweezers (meters).\n            phi (float): Polarization angle (radians).\n            P (list): Powers of optical tweezers (Watts).\n            n0 (list): Initial phonon occupation numbers.\n            w (float): Beam waist of optical tweezers (meters).\n            a (float): Radius of nanospheres (meters).\n            n (float): Refractive index of the nanospheres.\n            h (float): Step size for numerical derivative (meters).\n            rho (float): Density of nanospheres (kg/m\u00b3).\n            steps (int): Number of RK4 time steps.\n            L (np.ndarray, optional): Coupling matrix for the nanospheres.\n            M (np.ndarray, optional): Mass matrix for the nanospheres.\n            gamma (np.ndarray, optional): Damping coefficient for nanospheres.\n\n    Returns:\n            list: Phonon occupation numbers at time t0.\n    \"\"\"\n    k_ij = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i + 1, N):\n            R_ij = abs(i - j) * R\n            F_plus = calculate_binding_force([P[i], P[j]], phi, R_ij + h, l, w, a, n)\n            F_minus = calculate_binding_force([P[i], P[j]], phi, R_ij - h, l, w, a, n)\n            k_ij[i, j] = k_ij[j, i] = (F_plus - F_minus) / (2 * h)\n\n    if gamma is None:\n        gamma = np.zeros(N)\n\n    H = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\n    C0 = np.diag(n0)\n    C0 = C0 / np.max(C0)\n    if L is None:\n        L = -gamma[0] * np.identity(N) / 2\n    if M is None:\n        M = gamma[0] * np.identity(N) / 2\n\n    # Run dynamics\n    nf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\n    original_nf = nf * np.max(n0)\n    return original_nf\n",
    "general_tests": [
        "# Test Case 1: Standard Parameters with Uniform Damping\nn0 = [500, 400, 300, 200, 100]\nP = [50, 50, 50, 50, 50]\nphi = np.pi / 3\nR = 1.2e-6\nl = 1.5e-7\nw = 4e-7\na = 60e-9\nn = 1.55\nh = 1e-8\nN = len(P)\nrho = 2.5e3\nt0 = 2.0\nsteps = 500\ngamma = np.array([0.05] * N)\n\ntarget = [335.60668225, 351.97047581, 300.0, 248.02952419, 264.39331775]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, P, n0, w, a, n, h, rho, steps, gamma)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n\n# Test Case 2: Non-Uniform Damping with Increased Interaction Distance\nn0 = [1000, 800, 600, 400, 200]\nP = [50, 50, 50, 50, 50]\nphi = np.pi / 4\nR = 1.5e-6\nl = 1.0e-7\nw = 3.5e-7\na = 70e-9\nn = 1.6\nh = 2e-8\nN = len(P)\nrho = 2.0e3\nt0 = 1.5\nsteps = 500\ngamma = np.array([0.02, 0.025, 0.03, 0.035, 0.04])\n\ntarget = [663.82622781, 606.9717101, 600.0, 593.0282899, 536.17377219]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, P, n0, w, a, n, h, rho, steps, gamma)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n\n# Test Case 3: High Laser Power and Low Damping\nn0 = [300, 250, 200, 150, 100]\nP = [100, 100, 100, 100, 100]\nphi = np.pi / 6\nR = 1.0e-6\nl = 2.0e-7\nw = 5e-7\na = 50e-9\nn = 1.8\nh = 5e-9\nN = len(P)\nrho = 1.5e3\nt0 = 3.0\nsteps = 1000\ngamma = np.array([0.01] * N)\n\ntarget = [203.54836401, 247.02715081, 200.0, 152.97284919, 196.45163599]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, P, n0, w, a, n, h, rho, steps, gamma)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\"\n\n# Test Case 4: Extreme Initial Phonon Occupations\nn0 = [1e7, 200.0, 200.0, 200.0, 200.0]\nP = [100, 100, 100, 100, 100]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nt0 = 0.02\nsteps = 10000\ngamma = np.array([0.001] * N)\n\ntarget = [9.99410920e+06, 4.19814865e+03, 1.52417579e+03, 8.16956569e+02, 5.51508777e+02]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, P, n0, w, a, n, h, rho, steps, gamma)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4), f\"Output {output} does not match target {target}\""
    ]
}
